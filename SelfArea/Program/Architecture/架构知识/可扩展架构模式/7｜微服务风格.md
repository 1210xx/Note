微服务是一个模糊的概念，而不是一个标准，没有明确的定义。但微服务存在一定的风格，只要系统架构满足一定的风格，就可以被称为微服务架构。

为了更好地实现微服务的风格，Eric Brewer提出了微服务架构的九个风格。也就是说，对于满足以下九种风格的系统架构，我们都可以称之为微服务。

1. 组件化和服务

	- 组件化（componentization）
		- 把一个单体系统拆分为一个个可以单独维护和升级的软件单元，每一个单元就称为组件。
		- 每一个组件能够运行在自己独立的进程里，可以调用自己内部的函数（或方法）来完成自身独立的业务功能。
	- 服务（service）
		- 更多的时候组件之间需要**相互协作**才能完成业务，这些就需要通过服务来完成了。这里的服务是指进程外的组件，它允许我们调用其他的组件，服务一般会以**明确的通信机制提供**，如HTTP协议、Web Service或者远程过程调用（RPC）等。

2. 围绕业务功能组织团队

	单体应用包含用户界面、服务逻辑和数据源等内容。如果对团队进行划分，可以分为前端团队、后端团队、数据库团队和运维团队等。果以这样的团队划分作为微服务的划分，会出现比较大的问题。因为一个改动往往会同时牵涉到前端、后端和运维团队，所以即使是很小的业务改动，也会牵涉跨团队的协作。
	
3. 是产品而不是项目

	微服务则认为，这样的模式是不可取的，并且认为开发团队应该维护整个产品的生命周期，也就是谁开发谁负责后续的改进。因为微服务是帮助用户持续处理业务功能的，所以开发者持续关注软件，不断地改善软件，让软件更好地服务于业务，而且越小的粒度也越容易促进用户和服务供应商之间的关系。
	
4. 强化终端及弱化通道

	微服务的应用致力**松耦合和高内聚**，也就是业务模块的划分具有高内聚的特点，而各个业务组件则呈现出松耦合的特点。
	
	系统拆分后，需要各个组件相互协助才能完成业务，因此组件之间需要相互通信，为此开发者需要引入各种各样的通信协议。通信协议分很多种，如HTTP、WebService和RPC等。
	
	微服务的构建中，建议弱化通信协议的复杂性，因此推荐使用以下两种。

	- 包含资源**API的HTTP的请求-响应和轻量级消息通信协议**，尤其是现在流行的REST风格。
	
	- 用轻量级消息总线来发布消息，如RabbitMQ或者ZeroMQ等，可以提供可靠消息的中间件。

	在一些非常强调性能的网站，也许还会使用二进制来传递协议，但是这仍然不能解决分布式的丢包和请求丢失等问题。

5. 分散治理

	微服务架构的每一个组件所面对的业务焦点都是不一样的，因此在选型上有很大的差异。例如，C++适合做那些实时高效的组件，Node.js适合做报表组件，而Matlab则适合做数字图像分析。

	分散治理带来了很大的灵活性。与此同时，我们只需要通过接口约定即可实现组件之间的相互通信。例如，使用现在流行的HTTP请求的REST风格，就能够使系统之间十分简单地交互。

6. 分散数据管理

	单体系统拆分后，**微服务架构建议使用分散的数据管理**，也就是每一个组件都应该拥有自己的数据源，包括数据库和NoSQL等。这样就可以**按照微服务组件划分的规则，划分对应的数据**。这有助于更为精确地管理数据，可以使数据存储更加合理，同时还可以简化数据模型。

	分散数据管理也会引发两个弊端。
	- 因为数据库的拆分会导致原有的ACID特性不复存在，所以需**要实现分布式数据库事务的一致性**。为了实现它，还需要引入其他协议，如XA协议等。然而，这会使开发变得十分复杂，大大提高开发难度。所以微服务并不建议使用分布式事务来处理数据的一致性，而是建议使用最终一致性的原理。
	- 拆分之后关联计算会十分复杂。例如，交易组件要查看产品详情的时候，而产品详情却放在产品组件里，如果是在统计分析的情况下，则无法进行数据库的表关联计算，需要大量的远程过程调用才行，这样会造成性能低下，但是从现实来说在分布式系统中使用统计分析的场景较少，所以这样的场景出现频率较低。需要统计分析时，可以抽取数据到对应的系统再进行统计分析，毕竟统计分析一般不需要实时数据。

7. 基础设施自动化

	微服务是将一个单体系统拆分为多个组件，所以势必造成多个组件的测试和部署，这样就会大大增加测试人员和开发人员的工作量。在业务不断扩大的情况下，这些将会成为测试和运维人员的噩梦。好在当前的云计算、测试开发、容器（如Docker）等技术已经有了长足发展，减少了微服务的测试、构建和发布的复杂性。

	对于自动化测试，当前已有许多语言可用，如Node.js、Python等语言，都可以构建测试开发，验证测试案例。这是部署之前需要做的事情，可以降低测试人员的工作量。对于部署来说，借助容器化技术（如Docker）进行构建、部署微服务，可以极大地简化部署人员重复的操作和多环境的配置。

8. 容错性设计

	应用需要有能容忍服务的故障的设计。

	- 第一种情况是，任何服务器都可能出现故障、断电和宕机。在这样的情况下，**微服务架构应当可以给出仪表盘，监控每一个节点的状态是否正常、吞吐情况、内存等。** 一旦出现故障不可用时，微服务系统自动就会切断转发给它的请求，给出故障节点的提示，并且将被切断的请求转发给其他可用节点。**微服务系统也允许监测组件节点的状态（上线、下线或不可用）**，在某些组件节点出现故障、断点和宕机时，系统允许组件节点优雅下线进行维护。在企业维护成功后，允许其重新上线，再次提供服务。
	- 第二种情况是，当系统接收大量请求时，可能出现某个组件响应变得缓慢的情况。此时，如果其他的组件再调用该组件，就需要等待大量的时间。这样，其他的组件也会因为等待超时而引发自身组件不可用，继而出现服务器雪崩的场景。当一个组件变得响应缓慢，造成大量超时，如果**微服务能够发现它，并且通过一些手段将其隔离出去，这种情况就不会蔓延到调用者了。** 这就好比电流突然增大，可能会发生危险，保险丝便自动熔断保护用电安全一样。因此，我们把这种情况称为断路，把微服务中处理这种情况的组件称为**断路器（**Circuit Breaker）

9. 设计改进

	从上述的特征来看，实施微服务比实施一个单体系统复杂得多，代价也大得多。从实践的角度来说，**微服务的设计是循序渐进的**，在起初业务量不大的时候，系统是相对简单的，业务也是相对单一的。

	早期的核心架构在后期不会发生很大的变化，但系统会引入新的业务，使得一些内容发生变化，有些组件会被停用，有些组件会被加入进来。例如，用户数量不断增大且构成变得更复杂，这个时候可以把现有的用户服务拆分为高级用户服务和普通用户服务两个微服务产品，对外提供服务。经过时间的推移，那些核心架构的组件往往就会相对稳定下来，从而成为微服务的核心。而那些需要经常变化的组件，则需要不断地进行维护和改进，来满足业务的发展需要。